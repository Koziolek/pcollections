{"name":"pcollections","tagline":"A Persistent Java Collections Library","body":"###Overview\r\n\r\nPCollections serves as a [persistent](http://en.wikipedia.org/wiki/Persistent_data_structure) and immutable analogue of the [Java Collections Framework](http://java.sun.com/javase/6/docs/technotes/guides/collections/index.html). This includes **efficient**, **thread-safe**, **generic**, **immutable**, and **persistent** stacks, maps, vectors, sets, and bags, **compatible** with their Java Collections counterparts.\r\n\r\nPersistent and immutable datatypes are increasingly appreciated as a **simple**, **design-friendly**, **concurrency-friendly**, and sometimes more time- and space-efficient alternative to mutable datatypes.\r\n###Persistent versus Unmodifiable\r\n\r\nNote that these immutable collections are very different from the immutable collections returned by Java's [Collections.unmodifiableCollection()](http://java.sun.com/javase/6/docs/api/java/util/Collections.html#unmodifiableCollection(java.util.Collection)) and similar methods. The difference is that Java's unmodifiable collections have no producers, whereas PCollections have very efficient producers. Thus if you have an unmodifiable Collection x and you want a new Collection x2 consisting of the elements of x in addition to some element e, you would have to do something like:\r\n```Java\r\nCollection x2 = new HashSet(x);\r\nx2.add(e);\r\n```\r\nwhich involves copying all of x, using linear time and space. If, on the other hand, you have a PCollection y you can simply say:\r\n```Java\r\nPCollection y2 = y.plus(e);\r\n```\r\nwhich still leaves y untouched but generally requires little or no copying, using time and space much more efficiently.\r\n###Usage\r\n\r\nPCollections are created using producers and static factory methods. Some example static factory methods are [HashTreePSet.empty()](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/HashTreePSet.html#empty()) which returns an empty [PSet](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/PSet.html), while HashTreePSet.singleton(e) returns a PSet containing just the element e, and HashTreePSet.from(collection) returns a PSet containing the same elements as collection. See 'Example Code' below for an example of using producers.\r\n\r\nThe same empty(), singleton(), and from() factory methods are found in each of the PCollections implementations, which currently include one concrete implementation for each abstract type:\r\n* [HashTreePMap](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/HashTreePMap.html) provides a [PMap](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/PMap.html) implementation, analogous to Java's HashMap.\r\n* [ConsPStack](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/ConsPStack.html) provides a [PStack](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/PStack.html) implementation, analogous to Java's LinkedList.\r\n* [TreePVector](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/TreePVector.html) provides a [PVector](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/PVector.html) implementation, analogous to Java's ArrayList.\r\n* [HashTreePSet](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/HashTreePSet.html) provides a [PSet](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/PSet.html) implementation, analogous to Java's HashSet.\r\n* [HashTreePBag](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/HashTreePBag.html) provides a [PBag](http://pcollections.googlecode.com/svn/trunk/docs/org/pcollections/PBag.html) implementation, which is unordered like a set but can contain duplicate elements. \r\n\r\nPCollections are highly interoperable with Java Collections: every PCollection is a java.util.Collection, every PMap is a java.util.Map, every PSequence — including every PStack and PVector — is a java.util.List, and every PSet is a java.util.Set.\r\n\r\nPCollections uses [Semantic Versioning](http://semver.org/), which establishes a strong correspondence between API changes and version numbering.\r\n\r\nPCollections is in the [Maven Central repository](http://search.maven.org/#search|ga|1|a:%22pcollections%22), under org.pcollections. Thus the Maven coordinates for PCollections are:\r\n\r\n<dependency>\r\n    <groupId>org.pcollections</groupId>\r\n    <artifactId>pcollections</artifactId>\r\n    <version>2.1.2</version>\r\n</dependency>\r\n\r\n###Example Code\r\n\r\nThe following gives a very simple example of using PCollections, including the static factory method HashTreePSet.empty() and the producer plus(e):\r\n```Java\r\nimport pcollections.*;\r\npublic class Example {\r\n  public static void main(String... args) {\r\n    PSet<String> set = HashTreePSet.empty();\r\n    set = set.plus(\"something\");\r\n    System.out.println(set);\r\n    System.out.println(set.plus(\"something else\"));\r\n    System.out.println(set);\r\n  }\r\n}\r\n```\r\nRunning this program gives the following output:\r\n```\r\n[something]\r\n\r\n[something else, something]\r\n\r\n[something]\r\n```\r\n###Related Work\r\n\r\n[Clojure](http://clojure.googlecode.com/) also provides persistent collections in Java, but for now they are less interoperable with Java Collections, and seem more designed to be used within the Clojure language itself. Both [Guava](http://guava-libraries.googlecode.com/) and Java's [Collections](http://java.sun.com/javase/6/docs/api/java/util/Collections.html) utility class provide immutable collections but they are not persistent, that is they do not provide efficient producers, so they are not nearly as useful. See [Persistent versus Unmodifiable](#persistent-versus-unmodifiable) above. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}